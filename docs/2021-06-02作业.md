#### 1. hashCode与equals什么情况下需要重写？

在需要判断对象在业务逻辑上是否相等的时候需要重写`hashCode`与`equals`。

在我们的业务系统中判断对象时有时候需要的不是一种严格意义上的相等，而是一种业务上的对象相等。在这种情况下，原生的equals方法就不能满足我们的需求了。所以这个时候我们需要重写equals方法，来满足我们的业务系统上的需求。

**基于哈希的集合在使用`hashCode`的时配合`equals`一起使用：**

* **将两个对象加入HashSet，首先需要重写`hashCode`和`equals`的方法，重写后比较两个对象的`hashCode`值。**
* **若`hashCode`返回的值不同，则两个对象不同，返回`false`。**
* **若`hashCode`返回的值相同，则两个对象相同，再使用`equals`方法进行比较：**
  * **若equals方法返回的值相同，则两个对象相同，返回`true`；**
  * **若equals方法返回的值相同，则两个对象不同，返回`false`。**



#### 2. List的特点是什么？

有顺序以线性方式存储,可以存放重复对象，可以为`null`，长度可变



#### 3. Set的特点是什么？

无顺序,不包含重复的元素，可以为`null`，长度可变



#### 4. Map的特点是什么？

键值对，键必须是唯一，值可以重复，键和值可以为null



#### 5. 输出了但是报错java.util.NoSuchElementException什么意思？

由各种访问器方法抛出以指示所请求的元素不存在。

```java
class NoSuchElementException extends RuntimeException {
    
}
```



#### 6. 一个类如果能被克隆，这个类必须实现哪个接口？为什么？

一个类如果能被克隆,就必须实现`Cloneable`接口，否则在调用 `clone() `时会报 `CloneNotSupportedException `异常，也就是说， `Cloneable `接口只是个合法调用 `clone() `的标识。

**原因：如果Object的子类没有实现`Cloneable`接口，但是子类重写了`clone`方法，子类就会抛出异常。**



#### 7. 泛型为什么不能是int这些基本类型?<引用类型>

泛型只能只能代表引用类型，不能是基本类型，引用类型与基本类型的区别在于虽然二者保存在栈中，但原始类型保存的是实际值，而引用类型保存的是一个对象的内存地址。

* 泛型要求包容的是对象类型，而基本数据类型在Java中不属于对象。但是基本数据类型有其封装类，且为对象类型。
* 想放int类型，要放Integer类型不能直接放int（基本数据类型）。
* 基本数据类型不可以泛型化。但是相应的包装类型可以。因为只有Object及其子类才可以泛型化。
* 假设泛型为T，当该泛型类实例化时，T可以为Integer或者为String, 但是一个实例T不可能两者都是。表示泛型不确定，两者都可以。



#### 8. 哪些集合类型能够使用迭代器？为什么？

* List      
* Set 
* Map 
* 数组







